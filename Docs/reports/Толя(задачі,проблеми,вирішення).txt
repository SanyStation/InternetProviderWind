1. SAD - спочатку були проблеми з розумінням, що це таке(спочатку я подумав, що це розробити архітектуу програми), 
тому можна вважати проблем не було.

2. Проектуваня роботи всіх запитів через один сервлет, проблема була для обробки AJAX запитів, без перезавантаження сторінки, 
вирішив проблему, переробивши основний сервлет, а саме: добавив розпізнавання заголовку запиту, якщо це AJAX запит, то не робити
перенаправлення на нову сторінку, а просто повертати дані.

3. Розробка DAO: проблема з зациклюванням, вирішили при обговорнні з Оксаною і Сашею К., що заповнюватимемео посилання на інші сутності, тільки там де 
немає списку. Проблема з зациклюванням пропала)

4. e2e сценарій для SO. 
не зареєстрований або незалогінений користувач може переглядати карту і доступні сервіси, після того як він натискає
клавішу proceed to order ми не створюємо SO а кидаємо його на сторінку, де він може зареєструватись або залогінитись, 
після чого він повинен знову вибрати потрібний йому сервіс і вже залогінений натиснути proceed to order і вже тоді в базу 
додається SO з статусом Entering після чого він може його або підтвердити або відмінити. 
Просто раніше я думав, що не зареєстрований або незалогінений користувач може переглядати карту і доступні сервіси, після 
того як він натискає клавішу proceed to order, SO створюється, а він реєструється або логіниться і після цього його кидає на 
сторінку для підтвердження цього SO, але ми з Сашею К. дійшли висновку, що це неправильно, правильно перший варіант

5. ConnectionPool були незначні проблеми потокобезпечністю. Вирішив проблему, примінивши один з потокобезпечних патернів singletone. 
Також примінив в налаштуваннях пула відповідний рівень ізоляції транзакцій.

6. Dashboard for PE. Покищо проблем як таких немає, так як тільки почали реалізовувати даний функціонал. Потрібно повторити курсори в oracle 
і потім правильно їх примінити.

7. При створенні ServiceLocation треба було зразу мати його ID, щоб могти записати в базу створений SO, так як в нас автоінкремент то ми його немали.
Прблему ввирішили з Ванею наступним чином:
prepareStatement(INSERT, Statement.RETURN_GENERATED_KEYS);
ResultSet insertedResultSet = stat.getGeneratedKeys();
            if (insertedResultSet != null && insertedResultSet.next()) {
                String s = insertedResultSet.getString(1);
                PreparedStatement ps = connection.prepareStatement("select * from ROOT.SERVICE_LOCATIONS where rowid = ?");
                ps.setObject(1, s);
                ResultSet rs = ps.executeQuery();
                rs.next();
                serviceLocation.setId(rs.getInt(ID));
            }
			
тобто простими словами, в кожній таблиці є неявний стовпчик ROWID який є унікальним ідентифікатором запису, не тільки в цій таблиці, а й в всій БД.

8. Виникали інші не значні проблеми, які не потребували важкого вирішення, тому думаю недоцільно їх тут писати.

9. Задача PEDashboards
	Проблема 1:
		Чи потрібно, або чи має зміст перевіряти, що користувач який хоче змінити статус таска на Completed це той користувач, 
		який прив'язаний до таска?
	Вирішення:
		
	Проблема 2:
		Потрібно було потокобезпечно прив'язати таску до користувача і поміняи її статус
	Вирішення:
		Добавив і реалізував метод в ДАО, який витягає з бази потрібну таску, прив'язує користувача, міняє статус на Active і оновлює цей таск в БД.
		Все це зробив за допомогою транзакцій. 
		на початку:
		connection.setAutoCommit(false);
		в кінці:
		connection.commit();
		в catch:
		connection.rollback();
	
	Проблема 3:
		Для перегляду списку тасків використати Paging, щоб витягати з бази не всі зразу таски, а тільки при необхідності їх відображеня
	Вирішення:
		Зупинився на такому рішенні
		SELECT * FROM (
			SELECT ROWNUM rownumber, sub.*
			FROM
				(SELECT * FROM tasks 
				WHERE role_id = ?
				ORDER BY ID DESC) sub
			WHERE ROWNUM <= ?)
		WHERE rownumber > ?;
10. Задача е2е
	покищо особливих проблем не було